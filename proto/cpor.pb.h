// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: cpor.proto

#ifndef PROTOBUF_cpor_2eproto__INCLUDED
#define PROTOBUF_cpor_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace audit {
namespace proto {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_cpor_2eproto();
void protobuf_AssignDesc_cpor_2eproto();
void protobuf_ShutdownFile_cpor_2eproto();

class BlockTag;
class FileTag;
class ChallengeItem;
class Challenge;
class Proof;

// ===================================================================

class BlockTag : public ::google::protobuf::Message {
 public:
  BlockTag();
  virtual ~BlockTag();

  BlockTag(const BlockTag& from);

  inline BlockTag& operator=(const BlockTag& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BlockTag& default_instance();

  void Swap(BlockTag* other);

  // implements Message ----------------------------------------------

  inline BlockTag* New() const { return New(NULL); }

  BlockTag* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BlockTag& from);
  void MergeFrom(const BlockTag& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BlockTag* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 index = 1;
  inline void clear_index();
  static const int kIndexFieldNumber = 1;
  inline ::google::protobuf::uint64 index() const;
  inline void set_index(::google::protobuf::uint64 value);

  // optional bytes sigma = 2;
  inline void clear_sigma();
  static const int kSigmaFieldNumber = 2;
  inline const ::std::string& sigma() const;
  inline void set_sigma(const ::std::string& value);
  inline void set_sigma(const char* value);
  inline void set_sigma(const void* value, size_t size);
  inline ::std::string* mutable_sigma();
  inline ::std::string* release_sigma();
  inline void set_allocated_sigma(::std::string* sigma);

  // @@protoc_insertion_point(class_scope:audit.proto.BlockTag)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::uint64 index_;
  ::google::protobuf::internal::ArenaStringPtr sigma_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_cpor_2eproto();
  friend void protobuf_AssignDesc_cpor_2eproto();
  friend void protobuf_ShutdownFile_cpor_2eproto();

  void InitAsDefaultInstance();
  static BlockTag* default_instance_;
};
// -------------------------------------------------------------------

class FileTag : public ::google::protobuf::Message {
 public:
  FileTag();
  virtual ~FileTag();

  FileTag(const FileTag& from);

  inline FileTag& operator=(const FileTag& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FileTag& default_instance();

  void Swap(FileTag* other);

  // implements Message ----------------------------------------------

  inline FileTag* New() const { return New(NULL); }

  FileTag* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FileTag& from);
  void MergeFrom(const FileTag& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(FileTag* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 num_blocks = 1;
  inline void clear_num_blocks();
  static const int kNumBlocksFieldNumber = 1;
  inline ::google::protobuf::uint64 num_blocks() const;
  inline void set_num_blocks(::google::protobuf::uint64 value);

  // optional uint64 num_sectors = 2;
  inline void clear_num_sectors();
  static const int kNumSectorsFieldNumber = 2;
  inline ::google::protobuf::uint64 num_sectors() const;
  inline void set_num_sectors(::google::protobuf::uint64 value);

  // optional int32 sector_size = 3;
  inline void clear_sector_size();
  static const int kSectorSizeFieldNumber = 3;
  inline ::google::protobuf::int32 sector_size() const;
  inline void set_sector_size(::google::protobuf::int32 value);

  // repeated bytes alphas = 4;
  inline int alphas_size() const;
  inline void clear_alphas();
  static const int kAlphasFieldNumber = 4;
  inline const ::std::string& alphas(int index) const;
  inline ::std::string* mutable_alphas(int index);
  inline void set_alphas(int index, const ::std::string& value);
  inline void set_alphas(int index, const char* value);
  inline void set_alphas(int index, const void* value, size_t size);
  inline ::std::string* add_alphas();
  inline void add_alphas(const ::std::string& value);
  inline void add_alphas(const char* value);
  inline void add_alphas(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& alphas() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_alphas();

  // optional bytes hmac_code = 5;
  inline void clear_hmac_code();
  static const int kHmacCodeFieldNumber = 5;
  inline const ::std::string& hmac_code() const;
  inline void set_hmac_code(const ::std::string& value);
  inline void set_hmac_code(const char* value);
  inline void set_hmac_code(const void* value, size_t size);
  inline ::std::string* mutable_hmac_code();
  inline ::std::string* release_hmac_code();
  inline void set_allocated_hmac_code(::std::string* hmac_code);

  // optional bytes prf_key = 6;
  inline void clear_prf_key();
  static const int kPrfKeyFieldNumber = 6;
  inline const ::std::string& prf_key() const;
  inline void set_prf_key(const ::std::string& value);
  inline void set_prf_key(const char* value);
  inline void set_prf_key(const void* value, size_t size);
  inline ::std::string* mutable_prf_key();
  inline ::std::string* release_prf_key();
  inline void set_allocated_prf_key(::std::string* prf_key);

  // optional bytes p = 7;
  inline void clear_p();
  static const int kPFieldNumber = 7;
  inline const ::std::string& p() const;
  inline void set_p(const ::std::string& value);
  inline void set_p(const char* value);
  inline void set_p(const void* value, size_t size);
  inline ::std::string* mutable_p();
  inline ::std::string* release_p();
  inline void set_allocated_p(::std::string* p);

  // @@protoc_insertion_point(class_scope:audit.proto.FileTag)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::uint64 num_blocks_;
  ::google::protobuf::uint64 num_sectors_;
  ::google::protobuf::RepeatedPtrField< ::std::string> alphas_;
  ::google::protobuf::internal::ArenaStringPtr hmac_code_;
  ::google::protobuf::internal::ArenaStringPtr prf_key_;
  ::google::protobuf::internal::ArenaStringPtr p_;
  ::google::protobuf::int32 sector_size_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_cpor_2eproto();
  friend void protobuf_AssignDesc_cpor_2eproto();
  friend void protobuf_ShutdownFile_cpor_2eproto();

  void InitAsDefaultInstance();
  static FileTag* default_instance_;
};
// -------------------------------------------------------------------

class ChallengeItem : public ::google::protobuf::Message {
 public:
  ChallengeItem();
  virtual ~ChallengeItem();

  ChallengeItem(const ChallengeItem& from);

  inline ChallengeItem& operator=(const ChallengeItem& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ChallengeItem& default_instance();

  void Swap(ChallengeItem* other);

  // implements Message ----------------------------------------------

  inline ChallengeItem* New() const { return New(NULL); }

  ChallengeItem* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ChallengeItem& from);
  void MergeFrom(const ChallengeItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ChallengeItem* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 index = 1;
  inline void clear_index();
  static const int kIndexFieldNumber = 1;
  inline ::google::protobuf::int64 index() const;
  inline void set_index(::google::protobuf::int64 value);

  // optional bytes weight = 2;
  inline void clear_weight();
  static const int kWeightFieldNumber = 2;
  inline const ::std::string& weight() const;
  inline void set_weight(const ::std::string& value);
  inline void set_weight(const char* value);
  inline void set_weight(const void* value, size_t size);
  inline ::std::string* mutable_weight();
  inline ::std::string* release_weight();
  inline void set_allocated_weight(::std::string* weight);

  // @@protoc_insertion_point(class_scope:audit.proto.ChallengeItem)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::int64 index_;
  ::google::protobuf::internal::ArenaStringPtr weight_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_cpor_2eproto();
  friend void protobuf_AssignDesc_cpor_2eproto();
  friend void protobuf_ShutdownFile_cpor_2eproto();

  void InitAsDefaultInstance();
  static ChallengeItem* default_instance_;
};
// -------------------------------------------------------------------

class Challenge : public ::google::protobuf::Message {
 public:
  Challenge();
  virtual ~Challenge();

  Challenge(const Challenge& from);

  inline Challenge& operator=(const Challenge& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Challenge& default_instance();

  void Swap(Challenge* other);

  // implements Message ----------------------------------------------

  inline Challenge* New() const { return New(NULL); }

  Challenge* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Challenge& from);
  void MergeFrom(const Challenge& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Challenge* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .audit.proto.ChallengeItem items = 1;
  inline int items_size() const;
  inline void clear_items();
  static const int kItemsFieldNumber = 1;
  inline const ::audit::proto::ChallengeItem& items(int index) const;
  inline ::audit::proto::ChallengeItem* mutable_items(int index);
  inline ::audit::proto::ChallengeItem* add_items();
  inline const ::google::protobuf::RepeatedPtrField< ::audit::proto::ChallengeItem >&
      items() const;
  inline ::google::protobuf::RepeatedPtrField< ::audit::proto::ChallengeItem >*
      mutable_items();

  // @@protoc_insertion_point(class_scope:audit.proto.Challenge)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::RepeatedPtrField< ::audit::proto::ChallengeItem > items_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_cpor_2eproto();
  friend void protobuf_AssignDesc_cpor_2eproto();
  friend void protobuf_ShutdownFile_cpor_2eproto();

  void InitAsDefaultInstance();
  static Challenge* default_instance_;
};
// -------------------------------------------------------------------

class Proof : public ::google::protobuf::Message {
 public:
  Proof();
  virtual ~Proof();

  Proof(const Proof& from);

  inline Proof& operator=(const Proof& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Proof& default_instance();

  void Swap(Proof* other);

  // implements Message ----------------------------------------------

  inline Proof* New() const { return New(NULL); }

  Proof* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Proof& from);
  void MergeFrom(const Proof& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Proof* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes sigma = 1;
  inline void clear_sigma();
  static const int kSigmaFieldNumber = 1;
  inline const ::std::string& sigma() const;
  inline void set_sigma(const ::std::string& value);
  inline void set_sigma(const char* value);
  inline void set_sigma(const void* value, size_t size);
  inline ::std::string* mutable_sigma();
  inline ::std::string* release_sigma();
  inline void set_allocated_sigma(::std::string* sigma);

  // repeated bytes mus = 2;
  inline int mus_size() const;
  inline void clear_mus();
  static const int kMusFieldNumber = 2;
  inline const ::std::string& mus(int index) const;
  inline ::std::string* mutable_mus(int index);
  inline void set_mus(int index, const ::std::string& value);
  inline void set_mus(int index, const char* value);
  inline void set_mus(int index, const void* value, size_t size);
  inline ::std::string* add_mus();
  inline void add_mus(const ::std::string& value);
  inline void add_mus(const char* value);
  inline void add_mus(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& mus() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_mus();

  // @@protoc_insertion_point(class_scope:audit.proto.Proof)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr sigma_;
  ::google::protobuf::RepeatedPtrField< ::std::string> mus_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_cpor_2eproto();
  friend void protobuf_AssignDesc_cpor_2eproto();
  friend void protobuf_ShutdownFile_cpor_2eproto();

  void InitAsDefaultInstance();
  static Proof* default_instance_;
};
// ===================================================================


// ===================================================================

// BlockTag

// optional uint64 index = 1;
inline void BlockTag::clear_index() {
  index_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 BlockTag::index() const {
  // @@protoc_insertion_point(field_get:audit.proto.BlockTag.index)
  return index_;
}
inline void BlockTag::set_index(::google::protobuf::uint64 value) {
  
  index_ = value;
  // @@protoc_insertion_point(field_set:audit.proto.BlockTag.index)
}

// optional bytes sigma = 2;
inline void BlockTag::clear_sigma() {
  sigma_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& BlockTag::sigma() const {
  // @@protoc_insertion_point(field_get:audit.proto.BlockTag.sigma)
  return sigma_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BlockTag::set_sigma(const ::std::string& value) {
  
  sigma_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:audit.proto.BlockTag.sigma)
}
inline void BlockTag::set_sigma(const char* value) {
  
  sigma_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:audit.proto.BlockTag.sigma)
}
inline void BlockTag::set_sigma(const void* value, size_t size) {
  
  sigma_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:audit.proto.BlockTag.sigma)
}
inline ::std::string* BlockTag::mutable_sigma() {
  
  // @@protoc_insertion_point(field_mutable:audit.proto.BlockTag.sigma)
  return sigma_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BlockTag::release_sigma() {
  
  return sigma_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BlockTag::set_allocated_sigma(::std::string* sigma) {
  if (sigma != NULL) {
    
  } else {
    
  }
  sigma_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sigma);
  // @@protoc_insertion_point(field_set_allocated:audit.proto.BlockTag.sigma)
}

// -------------------------------------------------------------------

// FileTag

// optional uint64 num_blocks = 1;
inline void FileTag::clear_num_blocks() {
  num_blocks_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 FileTag::num_blocks() const {
  // @@protoc_insertion_point(field_get:audit.proto.FileTag.num_blocks)
  return num_blocks_;
}
inline void FileTag::set_num_blocks(::google::protobuf::uint64 value) {
  
  num_blocks_ = value;
  // @@protoc_insertion_point(field_set:audit.proto.FileTag.num_blocks)
}

// optional uint64 num_sectors = 2;
inline void FileTag::clear_num_sectors() {
  num_sectors_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 FileTag::num_sectors() const {
  // @@protoc_insertion_point(field_get:audit.proto.FileTag.num_sectors)
  return num_sectors_;
}
inline void FileTag::set_num_sectors(::google::protobuf::uint64 value) {
  
  num_sectors_ = value;
  // @@protoc_insertion_point(field_set:audit.proto.FileTag.num_sectors)
}

// optional int32 sector_size = 3;
inline void FileTag::clear_sector_size() {
  sector_size_ = 0;
}
inline ::google::protobuf::int32 FileTag::sector_size() const {
  // @@protoc_insertion_point(field_get:audit.proto.FileTag.sector_size)
  return sector_size_;
}
inline void FileTag::set_sector_size(::google::protobuf::int32 value) {
  
  sector_size_ = value;
  // @@protoc_insertion_point(field_set:audit.proto.FileTag.sector_size)
}

// repeated bytes alphas = 4;
inline int FileTag::alphas_size() const {
  return alphas_.size();
}
inline void FileTag::clear_alphas() {
  alphas_.Clear();
}
inline const ::std::string& FileTag::alphas(int index) const {
  // @@protoc_insertion_point(field_get:audit.proto.FileTag.alphas)
  return alphas_.Get(index);
}
inline ::std::string* FileTag::mutable_alphas(int index) {
  // @@protoc_insertion_point(field_mutable:audit.proto.FileTag.alphas)
  return alphas_.Mutable(index);
}
inline void FileTag::set_alphas(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:audit.proto.FileTag.alphas)
  alphas_.Mutable(index)->assign(value);
}
inline void FileTag::set_alphas(int index, const char* value) {
  alphas_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:audit.proto.FileTag.alphas)
}
inline void FileTag::set_alphas(int index, const void* value, size_t size) {
  alphas_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:audit.proto.FileTag.alphas)
}
inline ::std::string* FileTag::add_alphas() {
  return alphas_.Add();
}
inline void FileTag::add_alphas(const ::std::string& value) {
  alphas_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:audit.proto.FileTag.alphas)
}
inline void FileTag::add_alphas(const char* value) {
  alphas_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:audit.proto.FileTag.alphas)
}
inline void FileTag::add_alphas(const void* value, size_t size) {
  alphas_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:audit.proto.FileTag.alphas)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
FileTag::alphas() const {
  // @@protoc_insertion_point(field_list:audit.proto.FileTag.alphas)
  return alphas_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
FileTag::mutable_alphas() {
  // @@protoc_insertion_point(field_mutable_list:audit.proto.FileTag.alphas)
  return &alphas_;
}

// optional bytes hmac_code = 5;
inline void FileTag::clear_hmac_code() {
  hmac_code_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& FileTag::hmac_code() const {
  // @@protoc_insertion_point(field_get:audit.proto.FileTag.hmac_code)
  return hmac_code_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FileTag::set_hmac_code(const ::std::string& value) {
  
  hmac_code_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:audit.proto.FileTag.hmac_code)
}
inline void FileTag::set_hmac_code(const char* value) {
  
  hmac_code_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:audit.proto.FileTag.hmac_code)
}
inline void FileTag::set_hmac_code(const void* value, size_t size) {
  
  hmac_code_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:audit.proto.FileTag.hmac_code)
}
inline ::std::string* FileTag::mutable_hmac_code() {
  
  // @@protoc_insertion_point(field_mutable:audit.proto.FileTag.hmac_code)
  return hmac_code_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FileTag::release_hmac_code() {
  
  return hmac_code_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FileTag::set_allocated_hmac_code(::std::string* hmac_code) {
  if (hmac_code != NULL) {
    
  } else {
    
  }
  hmac_code_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hmac_code);
  // @@protoc_insertion_point(field_set_allocated:audit.proto.FileTag.hmac_code)
}

// optional bytes prf_key = 6;
inline void FileTag::clear_prf_key() {
  prf_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& FileTag::prf_key() const {
  // @@protoc_insertion_point(field_get:audit.proto.FileTag.prf_key)
  return prf_key_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FileTag::set_prf_key(const ::std::string& value) {
  
  prf_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:audit.proto.FileTag.prf_key)
}
inline void FileTag::set_prf_key(const char* value) {
  
  prf_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:audit.proto.FileTag.prf_key)
}
inline void FileTag::set_prf_key(const void* value, size_t size) {
  
  prf_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:audit.proto.FileTag.prf_key)
}
inline ::std::string* FileTag::mutable_prf_key() {
  
  // @@protoc_insertion_point(field_mutable:audit.proto.FileTag.prf_key)
  return prf_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FileTag::release_prf_key() {
  
  return prf_key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FileTag::set_allocated_prf_key(::std::string* prf_key) {
  if (prf_key != NULL) {
    
  } else {
    
  }
  prf_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), prf_key);
  // @@protoc_insertion_point(field_set_allocated:audit.proto.FileTag.prf_key)
}

// optional bytes p = 7;
inline void FileTag::clear_p() {
  p_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& FileTag::p() const {
  // @@protoc_insertion_point(field_get:audit.proto.FileTag.p)
  return p_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FileTag::set_p(const ::std::string& value) {
  
  p_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:audit.proto.FileTag.p)
}
inline void FileTag::set_p(const char* value) {
  
  p_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:audit.proto.FileTag.p)
}
inline void FileTag::set_p(const void* value, size_t size) {
  
  p_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:audit.proto.FileTag.p)
}
inline ::std::string* FileTag::mutable_p() {
  
  // @@protoc_insertion_point(field_mutable:audit.proto.FileTag.p)
  return p_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FileTag::release_p() {
  
  return p_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FileTag::set_allocated_p(::std::string* p) {
  if (p != NULL) {
    
  } else {
    
  }
  p_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), p);
  // @@protoc_insertion_point(field_set_allocated:audit.proto.FileTag.p)
}

// -------------------------------------------------------------------

// ChallengeItem

// optional int64 index = 1;
inline void ChallengeItem::clear_index() {
  index_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 ChallengeItem::index() const {
  // @@protoc_insertion_point(field_get:audit.proto.ChallengeItem.index)
  return index_;
}
inline void ChallengeItem::set_index(::google::protobuf::int64 value) {
  
  index_ = value;
  // @@protoc_insertion_point(field_set:audit.proto.ChallengeItem.index)
}

// optional bytes weight = 2;
inline void ChallengeItem::clear_weight() {
  weight_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ChallengeItem::weight() const {
  // @@protoc_insertion_point(field_get:audit.proto.ChallengeItem.weight)
  return weight_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ChallengeItem::set_weight(const ::std::string& value) {
  
  weight_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:audit.proto.ChallengeItem.weight)
}
inline void ChallengeItem::set_weight(const char* value) {
  
  weight_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:audit.proto.ChallengeItem.weight)
}
inline void ChallengeItem::set_weight(const void* value, size_t size) {
  
  weight_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:audit.proto.ChallengeItem.weight)
}
inline ::std::string* ChallengeItem::mutable_weight() {
  
  // @@protoc_insertion_point(field_mutable:audit.proto.ChallengeItem.weight)
  return weight_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ChallengeItem::release_weight() {
  
  return weight_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ChallengeItem::set_allocated_weight(::std::string* weight) {
  if (weight != NULL) {
    
  } else {
    
  }
  weight_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), weight);
  // @@protoc_insertion_point(field_set_allocated:audit.proto.ChallengeItem.weight)
}

// -------------------------------------------------------------------

// Challenge

// repeated .audit.proto.ChallengeItem items = 1;
inline int Challenge::items_size() const {
  return items_.size();
}
inline void Challenge::clear_items() {
  items_.Clear();
}
inline const ::audit::proto::ChallengeItem& Challenge::items(int index) const {
  // @@protoc_insertion_point(field_get:audit.proto.Challenge.items)
  return items_.Get(index);
}
inline ::audit::proto::ChallengeItem* Challenge::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:audit.proto.Challenge.items)
  return items_.Mutable(index);
}
inline ::audit::proto::ChallengeItem* Challenge::add_items() {
  // @@protoc_insertion_point(field_add:audit.proto.Challenge.items)
  return items_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::audit::proto::ChallengeItem >&
Challenge::items() const {
  // @@protoc_insertion_point(field_list:audit.proto.Challenge.items)
  return items_;
}
inline ::google::protobuf::RepeatedPtrField< ::audit::proto::ChallengeItem >*
Challenge::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:audit.proto.Challenge.items)
  return &items_;
}

// -------------------------------------------------------------------

// Proof

// optional bytes sigma = 1;
inline void Proof::clear_sigma() {
  sigma_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Proof::sigma() const {
  // @@protoc_insertion_point(field_get:audit.proto.Proof.sigma)
  return sigma_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Proof::set_sigma(const ::std::string& value) {
  
  sigma_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:audit.proto.Proof.sigma)
}
inline void Proof::set_sigma(const char* value) {
  
  sigma_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:audit.proto.Proof.sigma)
}
inline void Proof::set_sigma(const void* value, size_t size) {
  
  sigma_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:audit.proto.Proof.sigma)
}
inline ::std::string* Proof::mutable_sigma() {
  
  // @@protoc_insertion_point(field_mutable:audit.proto.Proof.sigma)
  return sigma_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Proof::release_sigma() {
  
  return sigma_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Proof::set_allocated_sigma(::std::string* sigma) {
  if (sigma != NULL) {
    
  } else {
    
  }
  sigma_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sigma);
  // @@protoc_insertion_point(field_set_allocated:audit.proto.Proof.sigma)
}

// repeated bytes mus = 2;
inline int Proof::mus_size() const {
  return mus_.size();
}
inline void Proof::clear_mus() {
  mus_.Clear();
}
inline const ::std::string& Proof::mus(int index) const {
  // @@protoc_insertion_point(field_get:audit.proto.Proof.mus)
  return mus_.Get(index);
}
inline ::std::string* Proof::mutable_mus(int index) {
  // @@protoc_insertion_point(field_mutable:audit.proto.Proof.mus)
  return mus_.Mutable(index);
}
inline void Proof::set_mus(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:audit.proto.Proof.mus)
  mus_.Mutable(index)->assign(value);
}
inline void Proof::set_mus(int index, const char* value) {
  mus_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:audit.proto.Proof.mus)
}
inline void Proof::set_mus(int index, const void* value, size_t size) {
  mus_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:audit.proto.Proof.mus)
}
inline ::std::string* Proof::add_mus() {
  return mus_.Add();
}
inline void Proof::add_mus(const ::std::string& value) {
  mus_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:audit.proto.Proof.mus)
}
inline void Proof::add_mus(const char* value) {
  mus_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:audit.proto.Proof.mus)
}
inline void Proof::add_mus(const void* value, size_t size) {
  mus_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:audit.proto.Proof.mus)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Proof::mus() const {
  // @@protoc_insertion_point(field_list:audit.proto.Proof.mus)
  return mus_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Proof::mutable_mus() {
  // @@protoc_insertion_point(field_mutable_list:audit.proto.Proof.mus)
  return &mus_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto
}  // namespace audit

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_cpor_2eproto__INCLUDED
