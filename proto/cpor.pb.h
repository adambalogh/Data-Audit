// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: cpor.proto

#ifndef PROTOBUF_cpor_2eproto__INCLUDED
#define PROTOBUF_cpor_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace audit {
namespace proto {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_cpor_2eproto();
void protobuf_AssignDesc_cpor_2eproto();
void protobuf_ShutdownFile_cpor_2eproto();

class BlockTag;
class PublicFileTag;
class PrivateFileTag;
class ChallengeItem;
class Challenge;
class Proof;

// ===================================================================

class BlockTag : public ::google::protobuf::Message {
 public:
  BlockTag();
  virtual ~BlockTag();

  BlockTag(const BlockTag& from);

  inline BlockTag& operator=(const BlockTag& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BlockTag& default_instance();

  void Swap(BlockTag* other);

  // implements Message ----------------------------------------------

  inline BlockTag* New() const { return New(NULL); }

  BlockTag* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BlockTag& from);
  void MergeFrom(const BlockTag& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BlockTag* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 index = 1;
  inline void clear_index();
  static const int kIndexFieldNumber = 1;
  inline ::google::protobuf::uint64 index() const;
  inline void set_index(::google::protobuf::uint64 value);

  // optional bytes sigma = 2;
  inline void clear_sigma();
  static const int kSigmaFieldNumber = 2;
  inline const ::std::string& sigma() const;
  inline void set_sigma(const ::std::string& value);
  inline void set_sigma(const char* value);
  inline void set_sigma(const void* value, size_t size);
  inline ::std::string* mutable_sigma();
  inline ::std::string* release_sigma();
  inline void set_allocated_sigma(::std::string* sigma);

  // @@protoc_insertion_point(class_scope:audit.proto.BlockTag)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::uint64 index_;
  ::google::protobuf::internal::ArenaStringPtr sigma_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_cpor_2eproto();
  friend void protobuf_AssignDesc_cpor_2eproto();
  friend void protobuf_ShutdownFile_cpor_2eproto();

  void InitAsDefaultInstance();
  static BlockTag* default_instance_;
};
// -------------------------------------------------------------------

class PublicFileTag : public ::google::protobuf::Message {
 public:
  PublicFileTag();
  virtual ~PublicFileTag();

  PublicFileTag(const PublicFileTag& from);

  inline PublicFileTag& operator=(const PublicFileTag& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PublicFileTag& default_instance();

  void Swap(PublicFileTag* other);

  // implements Message ----------------------------------------------

  inline PublicFileTag* New() const { return New(NULL); }

  PublicFileTag* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PublicFileTag& from);
  void MergeFrom(const PublicFileTag& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PublicFileTag* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 num_blocks = 1;
  inline void clear_num_blocks();
  static const int kNumBlocksFieldNumber = 1;
  inline ::google::protobuf::uint64 num_blocks() const;
  inline void set_num_blocks(::google::protobuf::uint64 value);

  // optional uint64 num_sectors = 2;
  inline void clear_num_sectors();
  static const int kNumSectorsFieldNumber = 2;
  inline ::google::protobuf::uint64 num_sectors() const;
  inline void set_num_sectors(::google::protobuf::uint64 value);

  // optional int32 sector_size = 3;
  inline void clear_sector_size();
  static const int kSectorSizeFieldNumber = 3;
  inline ::google::protobuf::int32 sector_size() const;
  inline void set_sector_size(::google::protobuf::int32 value);

  // optional bytes p = 4;
  inline void clear_p();
  static const int kPFieldNumber = 4;
  inline const ::std::string& p() const;
  inline void set_p(const ::std::string& value);
  inline void set_p(const char* value);
  inline void set_p(const void* value, size_t size);
  inline ::std::string* mutable_p();
  inline ::std::string* release_p();
  inline void set_allocated_p(::std::string* p);

  // optional string file_name = 5;
  inline void clear_file_name();
  static const int kFileNameFieldNumber = 5;
  inline const ::std::string& file_name() const;
  inline void set_file_name(const ::std::string& value);
  inline void set_file_name(const char* value);
  inline void set_file_name(const char* value, size_t size);
  inline ::std::string* mutable_file_name();
  inline ::std::string* release_file_name();
  inline void set_allocated_file_name(::std::string* file_name);

  // @@protoc_insertion_point(class_scope:audit.proto.PublicFileTag)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::uint64 num_blocks_;
  ::google::protobuf::uint64 num_sectors_;
  ::google::protobuf::internal::ArenaStringPtr p_;
  ::google::protobuf::internal::ArenaStringPtr file_name_;
  ::google::protobuf::int32 sector_size_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_cpor_2eproto();
  friend void protobuf_AssignDesc_cpor_2eproto();
  friend void protobuf_ShutdownFile_cpor_2eproto();

  void InitAsDefaultInstance();
  static PublicFileTag* default_instance_;
};
// -------------------------------------------------------------------

class PrivateFileTag : public ::google::protobuf::Message {
 public:
  PrivateFileTag();
  virtual ~PrivateFileTag();

  PrivateFileTag(const PrivateFileTag& from);

  inline PrivateFileTag& operator=(const PrivateFileTag& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PrivateFileTag& default_instance();

  void Swap(PrivateFileTag* other);

  // implements Message ----------------------------------------------

  inline PrivateFileTag* New() const { return New(NULL); }

  PrivateFileTag* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PrivateFileTag& from);
  void MergeFrom(const PrivateFileTag& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PrivateFileTag* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .audit.proto.PublicFileTag public_tag = 1;
  inline bool has_public_tag() const;
  inline void clear_public_tag();
  static const int kPublicTagFieldNumber = 1;
  inline const ::audit::proto::PublicFileTag& public_tag() const;
  inline ::audit::proto::PublicFileTag* mutable_public_tag();
  inline ::audit::proto::PublicFileTag* release_public_tag();
  inline void set_allocated_public_tag(::audit::proto::PublicFileTag* public_tag);

  // repeated bytes alphas = 2;
  inline int alphas_size() const;
  inline void clear_alphas();
  static const int kAlphasFieldNumber = 2;
  inline const ::std::string& alphas(int index) const;
  inline ::std::string* mutable_alphas(int index);
  inline void set_alphas(int index, const ::std::string& value);
  inline void set_alphas(int index, const char* value);
  inline void set_alphas(int index, const void* value, size_t size);
  inline ::std::string* add_alphas();
  inline void add_alphas(const ::std::string& value);
  inline void add_alphas(const char* value);
  inline void add_alphas(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& alphas() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_alphas();

  // optional bytes hmac_code = 3;
  inline void clear_hmac_code();
  static const int kHmacCodeFieldNumber = 3;
  inline const ::std::string& hmac_code() const;
  inline void set_hmac_code(const ::std::string& value);
  inline void set_hmac_code(const char* value);
  inline void set_hmac_code(const void* value, size_t size);
  inline ::std::string* mutable_hmac_code();
  inline ::std::string* release_hmac_code();
  inline void set_allocated_hmac_code(::std::string* hmac_code);

  // optional bytes prf_key = 4;
  inline void clear_prf_key();
  static const int kPrfKeyFieldNumber = 4;
  inline const ::std::string& prf_key() const;
  inline void set_prf_key(const ::std::string& value);
  inline void set_prf_key(const char* value);
  inline void set_prf_key(const void* value, size_t size);
  inline ::std::string* mutable_prf_key();
  inline ::std::string* release_prf_key();
  inline void set_allocated_prf_key(::std::string* prf_key);

  // @@protoc_insertion_point(class_scope:audit.proto.PrivateFileTag)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::audit::proto::PublicFileTag* public_tag_;
  ::google::protobuf::RepeatedPtrField< ::std::string> alphas_;
  ::google::protobuf::internal::ArenaStringPtr hmac_code_;
  ::google::protobuf::internal::ArenaStringPtr prf_key_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_cpor_2eproto();
  friend void protobuf_AssignDesc_cpor_2eproto();
  friend void protobuf_ShutdownFile_cpor_2eproto();

  void InitAsDefaultInstance();
  static PrivateFileTag* default_instance_;
};
// -------------------------------------------------------------------

class ChallengeItem : public ::google::protobuf::Message {
 public:
  ChallengeItem();
  virtual ~ChallengeItem();

  ChallengeItem(const ChallengeItem& from);

  inline ChallengeItem& operator=(const ChallengeItem& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ChallengeItem& default_instance();

  void Swap(ChallengeItem* other);

  // implements Message ----------------------------------------------

  inline ChallengeItem* New() const { return New(NULL); }

  ChallengeItem* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ChallengeItem& from);
  void MergeFrom(const ChallengeItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ChallengeItem* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 index = 1;
  inline void clear_index();
  static const int kIndexFieldNumber = 1;
  inline ::google::protobuf::uint64 index() const;
  inline void set_index(::google::protobuf::uint64 value);

  // optional bytes weight = 2;
  inline void clear_weight();
  static const int kWeightFieldNumber = 2;
  inline const ::std::string& weight() const;
  inline void set_weight(const ::std::string& value);
  inline void set_weight(const char* value);
  inline void set_weight(const void* value, size_t size);
  inline ::std::string* mutable_weight();
  inline ::std::string* release_weight();
  inline void set_allocated_weight(::std::string* weight);

  // @@protoc_insertion_point(class_scope:audit.proto.ChallengeItem)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::uint64 index_;
  ::google::protobuf::internal::ArenaStringPtr weight_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_cpor_2eproto();
  friend void protobuf_AssignDesc_cpor_2eproto();
  friend void protobuf_ShutdownFile_cpor_2eproto();

  void InitAsDefaultInstance();
  static ChallengeItem* default_instance_;
};
// -------------------------------------------------------------------

class Challenge : public ::google::protobuf::Message {
 public:
  Challenge();
  virtual ~Challenge();

  Challenge(const Challenge& from);

  inline Challenge& operator=(const Challenge& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Challenge& default_instance();

  void Swap(Challenge* other);

  // implements Message ----------------------------------------------

  inline Challenge* New() const { return New(NULL); }

  Challenge* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Challenge& from);
  void MergeFrom(const Challenge& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Challenge* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .audit.proto.PublicFileTag file_tag = 1;
  inline bool has_file_tag() const;
  inline void clear_file_tag();
  static const int kFileTagFieldNumber = 1;
  inline const ::audit::proto::PublicFileTag& file_tag() const;
  inline ::audit::proto::PublicFileTag* mutable_file_tag();
  inline ::audit::proto::PublicFileTag* release_file_tag();
  inline void set_allocated_file_tag(::audit::proto::PublicFileTag* file_tag);

  // repeated .audit.proto.ChallengeItem items = 2;
  inline int items_size() const;
  inline void clear_items();
  static const int kItemsFieldNumber = 2;
  inline const ::audit::proto::ChallengeItem& items(int index) const;
  inline ::audit::proto::ChallengeItem* mutable_items(int index);
  inline ::audit::proto::ChallengeItem* add_items();
  inline const ::google::protobuf::RepeatedPtrField< ::audit::proto::ChallengeItem >&
      items() const;
  inline ::google::protobuf::RepeatedPtrField< ::audit::proto::ChallengeItem >*
      mutable_items();

  // @@protoc_insertion_point(class_scope:audit.proto.Challenge)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::audit::proto::PublicFileTag* file_tag_;
  ::google::protobuf::RepeatedPtrField< ::audit::proto::ChallengeItem > items_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_cpor_2eproto();
  friend void protobuf_AssignDesc_cpor_2eproto();
  friend void protobuf_ShutdownFile_cpor_2eproto();

  void InitAsDefaultInstance();
  static Challenge* default_instance_;
};
// -------------------------------------------------------------------

class Proof : public ::google::protobuf::Message {
 public:
  Proof();
  virtual ~Proof();

  Proof(const Proof& from);

  inline Proof& operator=(const Proof& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Proof& default_instance();

  void Swap(Proof* other);

  // implements Message ----------------------------------------------

  inline Proof* New() const { return New(NULL); }

  Proof* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Proof& from);
  void MergeFrom(const Proof& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Proof* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes sigma = 1;
  inline void clear_sigma();
  static const int kSigmaFieldNumber = 1;
  inline const ::std::string& sigma() const;
  inline void set_sigma(const ::std::string& value);
  inline void set_sigma(const char* value);
  inline void set_sigma(const void* value, size_t size);
  inline ::std::string* mutable_sigma();
  inline ::std::string* release_sigma();
  inline void set_allocated_sigma(::std::string* sigma);

  // repeated bytes mus = 2;
  inline int mus_size() const;
  inline void clear_mus();
  static const int kMusFieldNumber = 2;
  inline const ::std::string& mus(int index) const;
  inline ::std::string* mutable_mus(int index);
  inline void set_mus(int index, const ::std::string& value);
  inline void set_mus(int index, const char* value);
  inline void set_mus(int index, const void* value, size_t size);
  inline ::std::string* add_mus();
  inline void add_mus(const ::std::string& value);
  inline void add_mus(const char* value);
  inline void add_mus(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& mus() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_mus();

  // @@protoc_insertion_point(class_scope:audit.proto.Proof)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr sigma_;
  ::google::protobuf::RepeatedPtrField< ::std::string> mus_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_cpor_2eproto();
  friend void protobuf_AssignDesc_cpor_2eproto();
  friend void protobuf_ShutdownFile_cpor_2eproto();

  void InitAsDefaultInstance();
  static Proof* default_instance_;
};
// ===================================================================


// ===================================================================

// BlockTag

// optional uint64 index = 1;
inline void BlockTag::clear_index() {
  index_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 BlockTag::index() const {
  // @@protoc_insertion_point(field_get:audit.proto.BlockTag.index)
  return index_;
}
inline void BlockTag::set_index(::google::protobuf::uint64 value) {
  
  index_ = value;
  // @@protoc_insertion_point(field_set:audit.proto.BlockTag.index)
}

// optional bytes sigma = 2;
inline void BlockTag::clear_sigma() {
  sigma_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& BlockTag::sigma() const {
  // @@protoc_insertion_point(field_get:audit.proto.BlockTag.sigma)
  return sigma_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BlockTag::set_sigma(const ::std::string& value) {
  
  sigma_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:audit.proto.BlockTag.sigma)
}
inline void BlockTag::set_sigma(const char* value) {
  
  sigma_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:audit.proto.BlockTag.sigma)
}
inline void BlockTag::set_sigma(const void* value, size_t size) {
  
  sigma_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:audit.proto.BlockTag.sigma)
}
inline ::std::string* BlockTag::mutable_sigma() {
  
  // @@protoc_insertion_point(field_mutable:audit.proto.BlockTag.sigma)
  return sigma_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BlockTag::release_sigma() {
  
  return sigma_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BlockTag::set_allocated_sigma(::std::string* sigma) {
  if (sigma != NULL) {
    
  } else {
    
  }
  sigma_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sigma);
  // @@protoc_insertion_point(field_set_allocated:audit.proto.BlockTag.sigma)
}

// -------------------------------------------------------------------

// PublicFileTag

// optional uint64 num_blocks = 1;
inline void PublicFileTag::clear_num_blocks() {
  num_blocks_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 PublicFileTag::num_blocks() const {
  // @@protoc_insertion_point(field_get:audit.proto.PublicFileTag.num_blocks)
  return num_blocks_;
}
inline void PublicFileTag::set_num_blocks(::google::protobuf::uint64 value) {
  
  num_blocks_ = value;
  // @@protoc_insertion_point(field_set:audit.proto.PublicFileTag.num_blocks)
}

// optional uint64 num_sectors = 2;
inline void PublicFileTag::clear_num_sectors() {
  num_sectors_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 PublicFileTag::num_sectors() const {
  // @@protoc_insertion_point(field_get:audit.proto.PublicFileTag.num_sectors)
  return num_sectors_;
}
inline void PublicFileTag::set_num_sectors(::google::protobuf::uint64 value) {
  
  num_sectors_ = value;
  // @@protoc_insertion_point(field_set:audit.proto.PublicFileTag.num_sectors)
}

// optional int32 sector_size = 3;
inline void PublicFileTag::clear_sector_size() {
  sector_size_ = 0;
}
inline ::google::protobuf::int32 PublicFileTag::sector_size() const {
  // @@protoc_insertion_point(field_get:audit.proto.PublicFileTag.sector_size)
  return sector_size_;
}
inline void PublicFileTag::set_sector_size(::google::protobuf::int32 value) {
  
  sector_size_ = value;
  // @@protoc_insertion_point(field_set:audit.proto.PublicFileTag.sector_size)
}

// optional bytes p = 4;
inline void PublicFileTag::clear_p() {
  p_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PublicFileTag::p() const {
  // @@protoc_insertion_point(field_get:audit.proto.PublicFileTag.p)
  return p_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PublicFileTag::set_p(const ::std::string& value) {
  
  p_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:audit.proto.PublicFileTag.p)
}
inline void PublicFileTag::set_p(const char* value) {
  
  p_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:audit.proto.PublicFileTag.p)
}
inline void PublicFileTag::set_p(const void* value, size_t size) {
  
  p_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:audit.proto.PublicFileTag.p)
}
inline ::std::string* PublicFileTag::mutable_p() {
  
  // @@protoc_insertion_point(field_mutable:audit.proto.PublicFileTag.p)
  return p_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PublicFileTag::release_p() {
  
  return p_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PublicFileTag::set_allocated_p(::std::string* p) {
  if (p != NULL) {
    
  } else {
    
  }
  p_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), p);
  // @@protoc_insertion_point(field_set_allocated:audit.proto.PublicFileTag.p)
}

// optional string file_name = 5;
inline void PublicFileTag::clear_file_name() {
  file_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PublicFileTag::file_name() const {
  // @@protoc_insertion_point(field_get:audit.proto.PublicFileTag.file_name)
  return file_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PublicFileTag::set_file_name(const ::std::string& value) {
  
  file_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:audit.proto.PublicFileTag.file_name)
}
inline void PublicFileTag::set_file_name(const char* value) {
  
  file_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:audit.proto.PublicFileTag.file_name)
}
inline void PublicFileTag::set_file_name(const char* value, size_t size) {
  
  file_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:audit.proto.PublicFileTag.file_name)
}
inline ::std::string* PublicFileTag::mutable_file_name() {
  
  // @@protoc_insertion_point(field_mutable:audit.proto.PublicFileTag.file_name)
  return file_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PublicFileTag::release_file_name() {
  
  return file_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PublicFileTag::set_allocated_file_name(::std::string* file_name) {
  if (file_name != NULL) {
    
  } else {
    
  }
  file_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), file_name);
  // @@protoc_insertion_point(field_set_allocated:audit.proto.PublicFileTag.file_name)
}

// -------------------------------------------------------------------

// PrivateFileTag

// optional .audit.proto.PublicFileTag public_tag = 1;
inline bool PrivateFileTag::has_public_tag() const {
  return !_is_default_instance_ && public_tag_ != NULL;
}
inline void PrivateFileTag::clear_public_tag() {
  if (public_tag_ != NULL) delete public_tag_;
  public_tag_ = NULL;
}
inline const ::audit::proto::PublicFileTag& PrivateFileTag::public_tag() const {
  // @@protoc_insertion_point(field_get:audit.proto.PrivateFileTag.public_tag)
  return public_tag_ != NULL ? *public_tag_ : *default_instance_->public_tag_;
}
inline ::audit::proto::PublicFileTag* PrivateFileTag::mutable_public_tag() {
  
  if (public_tag_ == NULL) {
    public_tag_ = new ::audit::proto::PublicFileTag;
  }
  // @@protoc_insertion_point(field_mutable:audit.proto.PrivateFileTag.public_tag)
  return public_tag_;
}
inline ::audit::proto::PublicFileTag* PrivateFileTag::release_public_tag() {
  
  ::audit::proto::PublicFileTag* temp = public_tag_;
  public_tag_ = NULL;
  return temp;
}
inline void PrivateFileTag::set_allocated_public_tag(::audit::proto::PublicFileTag* public_tag) {
  delete public_tag_;
  public_tag_ = public_tag;
  if (public_tag) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:audit.proto.PrivateFileTag.public_tag)
}

// repeated bytes alphas = 2;
inline int PrivateFileTag::alphas_size() const {
  return alphas_.size();
}
inline void PrivateFileTag::clear_alphas() {
  alphas_.Clear();
}
inline const ::std::string& PrivateFileTag::alphas(int index) const {
  // @@protoc_insertion_point(field_get:audit.proto.PrivateFileTag.alphas)
  return alphas_.Get(index);
}
inline ::std::string* PrivateFileTag::mutable_alphas(int index) {
  // @@protoc_insertion_point(field_mutable:audit.proto.PrivateFileTag.alphas)
  return alphas_.Mutable(index);
}
inline void PrivateFileTag::set_alphas(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:audit.proto.PrivateFileTag.alphas)
  alphas_.Mutable(index)->assign(value);
}
inline void PrivateFileTag::set_alphas(int index, const char* value) {
  alphas_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:audit.proto.PrivateFileTag.alphas)
}
inline void PrivateFileTag::set_alphas(int index, const void* value, size_t size) {
  alphas_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:audit.proto.PrivateFileTag.alphas)
}
inline ::std::string* PrivateFileTag::add_alphas() {
  return alphas_.Add();
}
inline void PrivateFileTag::add_alphas(const ::std::string& value) {
  alphas_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:audit.proto.PrivateFileTag.alphas)
}
inline void PrivateFileTag::add_alphas(const char* value) {
  alphas_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:audit.proto.PrivateFileTag.alphas)
}
inline void PrivateFileTag::add_alphas(const void* value, size_t size) {
  alphas_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:audit.proto.PrivateFileTag.alphas)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
PrivateFileTag::alphas() const {
  // @@protoc_insertion_point(field_list:audit.proto.PrivateFileTag.alphas)
  return alphas_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
PrivateFileTag::mutable_alphas() {
  // @@protoc_insertion_point(field_mutable_list:audit.proto.PrivateFileTag.alphas)
  return &alphas_;
}

// optional bytes hmac_code = 3;
inline void PrivateFileTag::clear_hmac_code() {
  hmac_code_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PrivateFileTag::hmac_code() const {
  // @@protoc_insertion_point(field_get:audit.proto.PrivateFileTag.hmac_code)
  return hmac_code_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PrivateFileTag::set_hmac_code(const ::std::string& value) {
  
  hmac_code_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:audit.proto.PrivateFileTag.hmac_code)
}
inline void PrivateFileTag::set_hmac_code(const char* value) {
  
  hmac_code_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:audit.proto.PrivateFileTag.hmac_code)
}
inline void PrivateFileTag::set_hmac_code(const void* value, size_t size) {
  
  hmac_code_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:audit.proto.PrivateFileTag.hmac_code)
}
inline ::std::string* PrivateFileTag::mutable_hmac_code() {
  
  // @@protoc_insertion_point(field_mutable:audit.proto.PrivateFileTag.hmac_code)
  return hmac_code_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PrivateFileTag::release_hmac_code() {
  
  return hmac_code_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PrivateFileTag::set_allocated_hmac_code(::std::string* hmac_code) {
  if (hmac_code != NULL) {
    
  } else {
    
  }
  hmac_code_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hmac_code);
  // @@protoc_insertion_point(field_set_allocated:audit.proto.PrivateFileTag.hmac_code)
}

// optional bytes prf_key = 4;
inline void PrivateFileTag::clear_prf_key() {
  prf_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PrivateFileTag::prf_key() const {
  // @@protoc_insertion_point(field_get:audit.proto.PrivateFileTag.prf_key)
  return prf_key_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PrivateFileTag::set_prf_key(const ::std::string& value) {
  
  prf_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:audit.proto.PrivateFileTag.prf_key)
}
inline void PrivateFileTag::set_prf_key(const char* value) {
  
  prf_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:audit.proto.PrivateFileTag.prf_key)
}
inline void PrivateFileTag::set_prf_key(const void* value, size_t size) {
  
  prf_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:audit.proto.PrivateFileTag.prf_key)
}
inline ::std::string* PrivateFileTag::mutable_prf_key() {
  
  // @@protoc_insertion_point(field_mutable:audit.proto.PrivateFileTag.prf_key)
  return prf_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PrivateFileTag::release_prf_key() {
  
  return prf_key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PrivateFileTag::set_allocated_prf_key(::std::string* prf_key) {
  if (prf_key != NULL) {
    
  } else {
    
  }
  prf_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), prf_key);
  // @@protoc_insertion_point(field_set_allocated:audit.proto.PrivateFileTag.prf_key)
}

// -------------------------------------------------------------------

// ChallengeItem

// optional uint64 index = 1;
inline void ChallengeItem::clear_index() {
  index_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 ChallengeItem::index() const {
  // @@protoc_insertion_point(field_get:audit.proto.ChallengeItem.index)
  return index_;
}
inline void ChallengeItem::set_index(::google::protobuf::uint64 value) {
  
  index_ = value;
  // @@protoc_insertion_point(field_set:audit.proto.ChallengeItem.index)
}

// optional bytes weight = 2;
inline void ChallengeItem::clear_weight() {
  weight_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ChallengeItem::weight() const {
  // @@protoc_insertion_point(field_get:audit.proto.ChallengeItem.weight)
  return weight_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ChallengeItem::set_weight(const ::std::string& value) {
  
  weight_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:audit.proto.ChallengeItem.weight)
}
inline void ChallengeItem::set_weight(const char* value) {
  
  weight_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:audit.proto.ChallengeItem.weight)
}
inline void ChallengeItem::set_weight(const void* value, size_t size) {
  
  weight_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:audit.proto.ChallengeItem.weight)
}
inline ::std::string* ChallengeItem::mutable_weight() {
  
  // @@protoc_insertion_point(field_mutable:audit.proto.ChallengeItem.weight)
  return weight_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ChallengeItem::release_weight() {
  
  return weight_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ChallengeItem::set_allocated_weight(::std::string* weight) {
  if (weight != NULL) {
    
  } else {
    
  }
  weight_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), weight);
  // @@protoc_insertion_point(field_set_allocated:audit.proto.ChallengeItem.weight)
}

// -------------------------------------------------------------------

// Challenge

// optional .audit.proto.PublicFileTag file_tag = 1;
inline bool Challenge::has_file_tag() const {
  return !_is_default_instance_ && file_tag_ != NULL;
}
inline void Challenge::clear_file_tag() {
  if (file_tag_ != NULL) delete file_tag_;
  file_tag_ = NULL;
}
inline const ::audit::proto::PublicFileTag& Challenge::file_tag() const {
  // @@protoc_insertion_point(field_get:audit.proto.Challenge.file_tag)
  return file_tag_ != NULL ? *file_tag_ : *default_instance_->file_tag_;
}
inline ::audit::proto::PublicFileTag* Challenge::mutable_file_tag() {
  
  if (file_tag_ == NULL) {
    file_tag_ = new ::audit::proto::PublicFileTag;
  }
  // @@protoc_insertion_point(field_mutable:audit.proto.Challenge.file_tag)
  return file_tag_;
}
inline ::audit::proto::PublicFileTag* Challenge::release_file_tag() {
  
  ::audit::proto::PublicFileTag* temp = file_tag_;
  file_tag_ = NULL;
  return temp;
}
inline void Challenge::set_allocated_file_tag(::audit::proto::PublicFileTag* file_tag) {
  delete file_tag_;
  file_tag_ = file_tag;
  if (file_tag) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:audit.proto.Challenge.file_tag)
}

// repeated .audit.proto.ChallengeItem items = 2;
inline int Challenge::items_size() const {
  return items_.size();
}
inline void Challenge::clear_items() {
  items_.Clear();
}
inline const ::audit::proto::ChallengeItem& Challenge::items(int index) const {
  // @@protoc_insertion_point(field_get:audit.proto.Challenge.items)
  return items_.Get(index);
}
inline ::audit::proto::ChallengeItem* Challenge::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:audit.proto.Challenge.items)
  return items_.Mutable(index);
}
inline ::audit::proto::ChallengeItem* Challenge::add_items() {
  // @@protoc_insertion_point(field_add:audit.proto.Challenge.items)
  return items_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::audit::proto::ChallengeItem >&
Challenge::items() const {
  // @@protoc_insertion_point(field_list:audit.proto.Challenge.items)
  return items_;
}
inline ::google::protobuf::RepeatedPtrField< ::audit::proto::ChallengeItem >*
Challenge::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:audit.proto.Challenge.items)
  return &items_;
}

// -------------------------------------------------------------------

// Proof

// optional bytes sigma = 1;
inline void Proof::clear_sigma() {
  sigma_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Proof::sigma() const {
  // @@protoc_insertion_point(field_get:audit.proto.Proof.sigma)
  return sigma_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Proof::set_sigma(const ::std::string& value) {
  
  sigma_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:audit.proto.Proof.sigma)
}
inline void Proof::set_sigma(const char* value) {
  
  sigma_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:audit.proto.Proof.sigma)
}
inline void Proof::set_sigma(const void* value, size_t size) {
  
  sigma_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:audit.proto.Proof.sigma)
}
inline ::std::string* Proof::mutable_sigma() {
  
  // @@protoc_insertion_point(field_mutable:audit.proto.Proof.sigma)
  return sigma_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Proof::release_sigma() {
  
  return sigma_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Proof::set_allocated_sigma(::std::string* sigma) {
  if (sigma != NULL) {
    
  } else {
    
  }
  sigma_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sigma);
  // @@protoc_insertion_point(field_set_allocated:audit.proto.Proof.sigma)
}

// repeated bytes mus = 2;
inline int Proof::mus_size() const {
  return mus_.size();
}
inline void Proof::clear_mus() {
  mus_.Clear();
}
inline const ::std::string& Proof::mus(int index) const {
  // @@protoc_insertion_point(field_get:audit.proto.Proof.mus)
  return mus_.Get(index);
}
inline ::std::string* Proof::mutable_mus(int index) {
  // @@protoc_insertion_point(field_mutable:audit.proto.Proof.mus)
  return mus_.Mutable(index);
}
inline void Proof::set_mus(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:audit.proto.Proof.mus)
  mus_.Mutable(index)->assign(value);
}
inline void Proof::set_mus(int index, const char* value) {
  mus_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:audit.proto.Proof.mus)
}
inline void Proof::set_mus(int index, const void* value, size_t size) {
  mus_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:audit.proto.Proof.mus)
}
inline ::std::string* Proof::add_mus() {
  return mus_.Add();
}
inline void Proof::add_mus(const ::std::string& value) {
  mus_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:audit.proto.Proof.mus)
}
inline void Proof::add_mus(const char* value) {
  mus_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:audit.proto.Proof.mus)
}
inline void Proof::add_mus(const void* value, size_t size) {
  mus_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:audit.proto.Proof.mus)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Proof::mus() const {
  // @@protoc_insertion_point(field_list:audit.proto.Proof.mus)
  return mus_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Proof::mutable_mus() {
  // @@protoc_insertion_point(field_mutable_list:audit.proto.Proof.mus)
  return &mus_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto
}  // namespace audit

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_cpor_2eproto__INCLUDED
